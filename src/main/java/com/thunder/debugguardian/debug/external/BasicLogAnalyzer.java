package com.thunder.debugguardian.debug.external;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Enhanced heuristic log analyzer. It inspects thread reports to identify the
 * most suspicious mods, prioritises stacks that originate outside the Minecraft
 * and JVM framework packages, and computes a confidence score based on how many
 * independent threads implicate the same code. This offers a much more
 * actionable explanation when an external AI service is not configured.
 */
public class BasicLogAnalyzer implements LogAnalyzer {

    private static final List<String> NEUTRAL_PREFIXES = List.of(
            "java.",
            "javax.",
            "sun.",
            "jdk.",
            "com.sun.",
            "net.minecraft.",
            "com.mojang.",
            "cpw.mods.",
            "net.neoforged.",
            "net.minecraftforge.",
            "org.apache.",
            "org.slf4j.",
            "org.spongepowered.",
            "org.lwjgl.",
            "io.netty.",
            "com.google.",
            "it.unimi.dsi.",
            "com.electronwill.",
            "com.mojang.blaze3d.",
            "org.objectweb.asm.",
            "com.thunder.debugguardian."
    );

    private static final int MAX_SAMPLE_THREADS = 3;

    @Override
    public String analyze(List<ThreadReport> threads) {
        if (threads.isEmpty()) {
            return "No thread information available.";
        }

        List<ThreadInsight> insights = threads.stream()
                .map(this::buildInsight)
                .collect(Collectors.toList());

        StringBuilder sb = new StringBuilder();
        sb.append("Thread analysis summary:\n");
        for (ThreadInsight insight : insights) {
            sb.append(insight.describe());
        }

        Map<String, Long> stateCounts = insights.stream()
                .collect(Collectors.groupingBy(t -> t.state, Collectors.counting()));

        sb.append('\n')
          .append("State distribution: ")
          .append(joinStateCounts(stateCounts))
          .append("\n\n");

        Map<String, ModInsight> modInsightMap = new HashMap<>();
        for (ThreadInsight insight : insights) {
            modInsightMap.computeIfAbsent(insight.mod, ModInsight::new).record(insight);
        }

        List<ModInsight> ranked = modInsightMap.values().stream()
                .sorted(Comparator.comparingDouble(ModInsight::score).reversed()
                        .thenComparingInt(ModInsight::threadCount).reversed()
                        .thenComparing(ModInsight::mod))
                .collect(Collectors.toList());

        if (!ranked.isEmpty()) {
            sb.append("Most suspicious mods:\n");
            ranked.stream()
                    .limit(5)
                    .forEach(mi -> sb.append(mi.describe()));
            sb.append("Confidence: ")
              .append(computeConfidence(ranked))
              .append('\n');
        } else {
            sb.append("No mod ownership information was available in the dump.\n");
        }

        sb.append("\nAnalysis generated by heuristic rules. Configure an AI key to enable the external analyzer when available.");

        return sb.toString();
    }

    private ThreadInsight buildInsight(ThreadReport report) {
        String mod = sanitizeMod(report.mod());
        String state = sanitizeState(report.state());
        List<String> stack = report.stack();
        String topFrame = stack.isEmpty() ? "unknown" : normalizeFrame(stack.get(0));
        String interestingFrame = findInterestingFrame(stack);
        boolean mainThread = isMainThread(report.thread());
        double score = computeScore(mod, state, stack.size(), interestingFrame, mainThread);
        return new ThreadInsight(report.thread(), mod, state, stack.size(), topFrame, interestingFrame, score, mainThread);
    }

    private static String sanitizeMod(String mod) {
        if (mod == null) {
            return "unknown";
        }
        String trimmed = mod.trim();
        if (trimmed.isEmpty() || trimmed.equalsIgnoreCase("none")) {
            return "unknown";
        }
        return trimmed;
    }

    private static String sanitizeState(String state) {
        if (state == null || state.isBlank()) {
            return "UNKNOWN";
        }
        return state.trim().toUpperCase(Locale.ROOT);
    }

    private static boolean isMainThread(String thread) {
        if (thread == null) {
            return false;
        }
        String lower = thread.toLowerCase(Locale.ROOT);
        return lower.contains("server thread")
                || lower.contains("client thread")
                || lower.contains("render thread")
                || lower.equals("main");
    }

    private static String normalizeFrame(String frame) {
        if (frame == null) {
            return "unknown";
        }
        String trimmed = frame.trim();
        if (trimmed.startsWith("at ")) {
            trimmed = trimmed.substring(3);
        }
        return trimmed.isEmpty() ? "unknown" : trimmed;
    }

    private static String findInterestingFrame(List<String> stack) {
        for (String frame : stack) {
            String normalized = normalizeFrame(frame);
            if (normalized.equals("unknown")) {
                continue;
            }
            if (!isFrameworkFrame(normalized)) {
                return normalized;
            }
        }
        return null;
    }

    private static boolean isFrameworkFrame(String frame) {
        String lower = frame.toLowerCase(Locale.ROOT);
        for (String prefix : NEUTRAL_PREFIXES) {
            if (lower.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }

    private static double computeScore(String mod, String state, int stackDepth, String interestingFrame, boolean mainThread) {
        double score = 1.0;

        if (!"unknown".equalsIgnoreCase(mod)) {
            score += 1.5;
        } else {
            score -= 0.5;
        }

        switch (state) {
            case "RUNNABLE" -> score += 2.0;
            case "BLOCKED" -> score += 1.5;
            case "WAITING", "TIMED_WAITING" -> score += 0.5;
            case "TERMINATED" -> score -= 0.5;
            default -> {
            }
        }

        if (interestingFrame != null) {
            score += 2.0;
        }

        if (mainThread) {
            score += 1.5;
        }

        if (stackDepth > 0) {
            score += Math.min(1.5, stackDepth / 30.0);
        } else {
            score -= 0.5;
        }

        return Math.max(0.1, score);
    }

    private static String joinStateCounts(Map<String, Long> counts) {
        if (counts.isEmpty()) {
            return "none recorded";
        }
        return counts.entrySet().stream()
                .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
                .map(e -> e.getKey() + " (" + e.getValue() + ")")
                .collect(Collectors.joining(", "));
    }

    private static String computeConfidence(List<ModInsight> ranked) {
        List<ModInsight> known = ranked.stream()
                .filter(mi -> !mi.mod.equalsIgnoreCase("unknown"))
                .collect(Collectors.toList());

        if (known.isEmpty()) {
            return "Low - dump did not include mod ownership information.";
        }

        ModInsight top = known.get(0);
        double topScore = top.score();
        double secondScore = known.size() > 1 ? known.get(1).score() : 0.0;

        if (topScore < 2.0) {
            return "Low - signals implicating " + top.mod() + " are weak.";
        }

        if (secondScore == 0.0) {
            return top.threadCount() >= 2
                    ? "High - only " + top.mod() + " appears in problematic threads."
                    : "Medium - only a single thread implicates " + top.mod() + ".";
        }

        double ratio = topScore / Math.max(0.1, secondScore);
        if (ratio >= 1.8 && top.threadCount() >= 2) {
            return "High - " + top.mod() + " dominates the suspicious activity.";
        }
        if (ratio >= 1.2) {
            return "Medium - " + top.mod() + " edges out other candidates.";
        }
        return "Low - multiple mods exhibit comparable signals.";
    }

    private static String formatScore(double score) {
        return String.format(Locale.ROOT, "%.2f", score);
    }

    private static final class ThreadInsight {
        private final String thread;
        private final String mod;
        private final String state;
        private final int stackDepth;
        private final String topFrame;
        private final String interestingFrame;
        private final double score;
        private final boolean mainThread;

        private ThreadInsight(String thread, String mod, String state, int stackDepth,
                              String topFrame, String interestingFrame, double score, boolean mainThread) {
            this.thread = thread;
            this.mod = mod;
            this.state = state;
            this.stackDepth = stackDepth;
            this.topFrame = topFrame;
            this.interestingFrame = interestingFrame;
            this.score = score;
            this.mainThread = mainThread;
        }

        private String describe() {
            StringBuilder sb = new StringBuilder();
            sb.append("- ").append(thread)
              .append(" [").append(state).append("] mod: ")
              .append(mod);
            if (mainThread) {
                sb.append(" (main thread)");
            }
            sb.append('\n');
            sb.append("  stack depth: ").append(stackDepth)
              .append(", suspicion score: ")
              .append(formatScore(score)).append('\n');
            String frame = bestFrame();
            if (frame != null && !frame.equals("unknown")) {
                sb.append("  focus frame: ").append(frame).append('\n');
            } else {
                sb.append("  stack data unavailable\n");
            }
            return sb.toString();
        }

        private String bestFrame() {
            return interestingFrame != null ? interestingFrame : topFrame;
        }
    }

    private static final class ModInsight {
        private final String mod;
        private double totalScore;
        private int threadCount;
        private boolean touchesMainThread;
        private final Map<String, Integer> stateCounts = new LinkedHashMap<>();
        private final List<String> sampleThreads = new ArrayList<>();

        private ModInsight(String mod) {
            this.mod = mod;
        }

        private void record(ThreadInsight thread) {
            totalScore += thread.score;
            threadCount++;
            touchesMainThread |= thread.mainThread;
            stateCounts.merge(thread.state, 1, Integer::sum);
            if (sampleThreads.size() < MAX_SAMPLE_THREADS) {
                sampleThreads.add(thread.thread + " [" + thread.state + "] -> " + thread.bestFrame());
            }
        }

        private double score() {
            return totalScore;
        }

        private int threadCount() {
            return threadCount;
        }

        private String mod() {
            return mod;
        }

        private String describe() {
            StringBuilder sb = new StringBuilder();
            sb.append("- ").append(mod)
              .append(" — score ")
              .append(formatScore(totalScore))
              .append(" across ")
              .append(threadCount)
              .append(" thread(s)");
            if (touchesMainThread) {
                sb.append(" (impacts main thread)");
            }
            sb.append('\n');
            if (!stateCounts.isEmpty()) {
                sb.append("  states: ");
                sb.append(stateCounts.entrySet().stream()
                        .map(e -> e.getKey() + " x" + e.getValue())
                        .collect(Collectors.joining(", ")));
                sb.append('\n');
            }
            for (String sample : sampleThreads) {
                sb.append("  • ").append(sample).append('\n');
            }
            return sb.toString();
        }
    }
}
